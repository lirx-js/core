# ðŸ„¾ reactiveFunction

Alternative: `functionI$$`

### Types

```ts
function reactiveFunction<GFunction extends IGenericFunction>(
  observables: IReactiveFunctionObservables<GFunction>,
  fnc: GFunction,
): IReactiveFunctionReturn<GFunction>
```

### Definition

Creates an output Observable which aggregates the values from all the Observables passed as arguments.
When an Observable changes, the function is called, and the return is emitted.

It simply does:

```ts
pipe$$(combineLatest<GObservables>(observables), [
  map$$$<GCombineLastObservables, GOut>((args: GCombineLastObservables) => fnc(...(args as any))),
]);
```

`@lirx/core` comes with some common predefined `reactiveFunction`'s that you can find on the side bar.


If you prefer to have a function which handles changes in batch you may want to use:
[optimizedReactiveFunction](../optimized-reactive-function)

### Diagram

[//]: # (TODO)

### Examples

#### Perform the "sum" of two Observables

```ts
const obs1 = let$$<number>(0);
const obs2 = let$$<number>(0);

const subscribe = reactiveFunction(
  [obs1.subscribe, obs2.subscribe],
  (a: number, b: number) => {
    return a + b;
  },
);

subscribe((sum: number) => {
  console.log(sum);
});
// => 0
obs1.emit(2); // => 2
obs2.emit(1); // => 3
```

Output:

```text
0
2
3
```

---
:::caution

You should avoid using a lot of ReactiveFunctions when you could just create one.

:::

If you want to achieve:

```text
((obs1 + obs2) * obs3) === obs4
```

```ts
// AVOID
eq$$(mul$$(add$$(obs1, obs2), obs3), obs4);

// PREFER
reactiveFunction(
  [obs1, obs2, obs3, obs4],
  (obs1, obs2, obs3, obs4) => {
    return ((obs1 + ob2) * obs3) === obs4;
  },
);
```

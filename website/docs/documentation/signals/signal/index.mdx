# Signal

## Fundamentals

A Signal is simply a function returning immediately its value (as opposed to an Observable whose value is async):

```ts
interface IReadonlySignal<GValue> {
  (): GValue;

  toObservable(
    options?: ISignalToValueObservableOptions<GValue>,
  ): IObservable<GValue>;
  toObservable(
    options: ISignalToNotificationsObservableOptions,
  ): IObservable<ISignalNotifications<GValue>>;

  [SIGNAL]: unknown;
}
```

This function is marked with the `SIGNAL` symbol so the framework can recognize signals and apply internal optimizations.

Signals are fundamentally read-only: we can ask for the current value and observe change notification.

This function is used to access the current value *and* record signal read in a reactive context - this is an essential operation that builds the reactive dependencies graph.

Signal reads outside of the reactive context are permitted.
This means that non-reactive code (ex.: existing, 3rd party libraries) can always read the signal's value, without being aware of its reactive nature.

The documentation of the `toObservable` method [can be found here](/docs/documentation/signals/observables-and-signals/#signaltoobservable).

## Writable signals

When creating a Signal with the [signal](#create-a-signal) function (explained later), you'll receive a writable signal:

```ts
interface ISignal<GValue> extends IReadonlySignal<GValue> {
  set(
    value: GValue,
    force?: boolean, // (default: false)
  ): void;

  update(
    updateFunction: ISignalUpdateFunctionCallback<GValue>,
  ): void;

  mutate<GMutableValue extends GValue>(
    mutateFunction: ISignalMutateFunctionCallback<GMutableValue>,
  ): void;

  throw(
    error: any,
  ): void;
}
```

### set(...)

This method directly sets the Signal to a new value, and notifies any dependents.

Useful for changing primitive values or replacing data structures when
the new value is independent of the old one.

If `force` is set to true, then the Signal is updated even if the provided
value is equal to its own current value.

### update(...)

This method updates the value of the Signal based on its current value, and notifies any dependents.

Useful for setting a new value that depends on the old value, such as updating an immutable data structure.

It accepts an `updateFunction`:

```ts
interface ISignalUpdateFunctionCallback<GValue> {
  (
    value: GValue,
  ): GValue;
}
```

### mutate(...)

This method updates the current value by mutating it in-place and notifying any dependents.

Useful for making internal changes to the Signal's value without changing
its identity, such as pushing to an array stored in the Signal.

It accepts a `mutateFunction`:

```ts
interface ISignalMutateFunctionCallback<GMutableValue> {
  (
    value: GMutableValue,
  ): void;
}
```

`update` and `mutate` are simply shorter and convenient manners to combine a signal read and write in one call (`count.update(c => c + 1)` &lt;=&gt; `count.set(count() + 1)`).

### throw(...)

This method puts the signal in *"error"* state, and notifies any dependents.

When getting the value of the signal by calling it (ex: `const value = count();`), it will throw the provided error.

**This state is not definitive:** an errored signal may re-enter in a *"normal"* state when setting a value through `set(...)` for example.

## Create a Signal

An instance of a writable Signal can be created using the `signal` creation function:

```ts
function signal<GValue>(
  initialValue: GValue | SignalThrow,
  options?: ISignalOptions<GValue>,
): ISignal<GValue>
```

This functions receives as first argument an `initialValue`:

- if this value is an instance of `SignalThrow`, then the signal is initialized with an *"error"* state.
- else the signal is initialized with this value.

Because signals are sync, the `initialValue` must be given to set the initial state of this signal.

Then, it's possible to provide an optional `ISignalOptions` argument:


```ts
interface ISignalOptions<GValue> {
  readonly equal?: IEqualFunction<GValue>;
}

interface IEqualFunction<GValue> {
  (
    a: GValue,
    b: GValue,
  ): boolean;
}
```


- `equal`: this function is used to compare values passed to the `set` method.
If this equality function determines that 2 values are equal, and `force` is not `true`, then the value is simply ignored, and the change propagation is skipped.
  - `EQUAL_FUNCTION_STRICT_EQUAL`: (default) - compares values using the strict equality `===`.
  - `EQUAL_FUNCTION_NON_PRIMITIVES_ALWAYS_FALSE`: compares primitive values (numbers, strings, etc) using `===` semantics
    but treats objects and arrays as "always unequal".
    This allows Signals to hold non-primitive values (objects, arrays) and still propagate change notification.

#### thrownSignal

```ts
function thrownSignal<GValue>(
  error: any,
  options?: ISignalOptions<GValue>,
): ISignal<GValue>
```

This is simply a shortcut to `signal<GValue>(new SignalThrow(error), options)`.


#### uninitializedSignal

```ts
function uninitializedSignal<GValue>(
  options?: ISignalOptions<GValue>,
): ISignal<GValue>
```

This is simply a shortcut to `thrownSignal<GValue>(new Error(`The signal has no value.`), options)`.

## Examples

### Create a signal and set its value

```ts
// create a writable signal
const counter = signal(0);

// set a new signal value, completely replacing the current one
counter.set(5);

// update signal's value based on the current one
counter.update(currentValue => currentValue + 1);
```

### Create a signal with an immutable value

```ts
const names = signal<readonly string[]>(['Alice']);

// "update" is convenient to modify immutable data structures
names.update(names => ([
  ...names,
  'Bob',
]));
```

### Create a signal with a mutable array as value

```ts
const names = signal<readonly string[]>(['Alice']);

// "mutate" is convenient to modify data structures whose content changes but not their reference (objects and arrays)
names.mutate<string[]>(names => {
  names.push('Bob');
});
```

### Cast a Signal to an Observable

```ts
const counter = signal(0);

const counter$ = counter.toObservable();

counter$((count: number) => {
  console.log(`count: ${count}`);
});

window.onclick = () => {
  counter.set(counter() + 1);
};
```

Outputs:

```text
count: 0
// on click
count: 1
// ...
```

### Creates a signal in an "error" state

```ts
const counter = thrownSignal<number>(new Error(`Not a Number`));

const run = () => {
  try {
    if (counter() > 0) {
      // ... do something
    }
  } catch {
    console.log('Oops, counter is errored.');
    // let's fix it
    counter.set(1);
    run();
  }
};
```


import { $log, createMulticastSource, IObservable, IObserver, IUnsubscribeOfObservable } from '@lirx/core';

/** SIGNAL **/

interface IRegisterSignalObservable {
  (
    subscribe: IObservable<void>,
  ): void;
}

type IRegisterSignalObservableOrUndefined = IRegisterSignalObservable | undefined;

let REGISTER_SIGNAL_OBSERVABLE: IRegisterSignalObservableOrUndefined = void 0;

export interface ISignal<GValue> {
  (): GValue;
}

export interface IWritableSignal<GValue> extends ISignal<GValue> {
  // readonly $: IObservable<GValue>;
  set(value: GValue): void;
}

export function signal<GValue>(
  initialValue: GValue,
): IWritableSignal<GValue> {
  const source = createMulticastSource<void>();

  const signal = (): GValue => {
    if (REGISTER_SIGNAL_OBSERVABLE) {
      REGISTER_SIGNAL_OBSERVABLE(source.subscribe);
    }
    return initialValue;
  };

  signal.set = (
    value: GValue,
    force: boolean = false,
  ): void => {
    if (REGISTER_SIGNAL_OBSERVABLE === void 0) {
      if (
        force
        || (value !== initialValue)
      ) {
        initialValue = value;
        source.emit();
      }
    } else {
      throw new Error(`Values cannot be updated in an effect context`);
    }
  };

  // signal.update = (
  //   updateFn: (value: GValue) => GValue,
  // ): void => {
  //   signal.set(updateFn(initialValue));
  // };
  //
  // signal.mutate = (
  //   mutatorFn: (value: GValue) => void,
  // ): void => {
  //   mutatorFn(initialValue);
  //   signal.set(initialValue, true);
  // };

  return signal;
}

/** EFFECT **/

interface ISignalContextFunction {
  (): IUnsubscribeOfObservable | void;
}

interface ISignalContextOnChangeFunction {
  (): void;
}

function signalContext(
  signalContextFunction: ISignalContextFunction,
  signalContextOnChangeFunction: ISignalContextOnChangeFunction,
): IUnsubscribeOfObservable {
  let running: boolean = true;

  const subscriptions = new Map<IObservable<void>, IUnsubscribeOfObservable>();

  const end = (): void => {
    if (running) {
      running = false;

      const iterator: Iterator<IUnsubscribeOfObservable> = subscriptions.values();
      let result: IteratorResult<IUnsubscribeOfObservable>;
      while (!(result = iterator.next()).done) {
        result.value();
      }
      // subscriptions.clear();

      if (unsubscribe !== void 0) {
        unsubscribe();
      }
    }
  };

  const parentRegisterSignalObservable: IRegisterSignalObservableOrUndefined = REGISTER_SIGNAL_OBSERVABLE;

  REGISTER_SIGNAL_OBSERVABLE = (
    subscribe: IObservable<void>,
  ): void => {
    if (!subscriptions.has(subscribe)) {
      subscriptions.set(
        subscribe,
        subscribe((): void => {
          if (running) {
            end();
            signalContextOnChangeFunction();
          }
        }),
      );
    }
  };

  const unsubscribe = signalContextFunction();

  REGISTER_SIGNAL_OBSERVABLE = parentRegisterSignalObservable;

  return end;
}

/* EFFECT */

export interface IEffetFunction {
  (): void;
}

export function effect(
  effectFunction: IEffetFunction,
): IUnsubscribeOfObservable {
  let end!: IUnsubscribeOfObservable;

  const update = () => {
    end = signalContext(
      effectFunction,
      update,
    );
  };

  update();

  return end;
}

/** COMPUTED **/

export interface IComputedFunction<GValue> {
  (): GValue;
}

type IComputedState =
  | 0 // uninitialized
  | 1 // change detected
  | 2 // value cached
;

export function computed<GValue>(
  computedFunction: IComputedFunction<GValue>,
): ISignal<GValue> {
  const source = createMulticastSource<void>();
  let value: GValue;
  let state: IComputedState = 0;

  const update = (): void => {
    signalContext(
      (): void => {
        const _value: GValue = computedFunction();

        if (_value !== value) {
          value = _value;

          if (state === 1) {
            source.emit();
          }
        }

        state = 2;
      },
      (): void => {
        state = 1;
        update();
      },
    );
  };

  return (): GValue => {
    if (REGISTER_SIGNAL_OBSERVABLE) {
      REGISTER_SIGNAL_OBSERVABLE(source.subscribe);
    }

    if (state === 0) {
      update();
    }

    return value;
  };
}

export function signalToObservable<GValue>(
  signal: ISignal<GValue>,
): IObservable<GValue> {
  return (emit: IObserver<GValue>): IUnsubscribeOfObservable => {
    return effect((): void => {
      emit(signal());
    });
  };
}

export function debugSignals(): void {
  const a = signal(1);
  const b = signal(2);

  const c = computed(() => a() + b());

  const unsub = effect(() => {
    // console.log('effect', a() + b());
    console.log('effect', c());
  });

  // const c$ = signalToObservable(c);
  // c$($log);

  // effect(() => {
  //   // console.log('effect', a() + b());
  //   console.log('effect', c());
  // });

  a.set(3);
  // unsub();
  // b.set(3);

}



import { Callable, EQUAL_FUNCTION_STRICT_EQUAL, IEqualFunction } from '@lirx/utils';
import { SignalContextError } from '../../../error/signal-context-error.class';
import { SignalThrow } from '../../../error/signal-throw.class';
import { getCurrentSignalChangeListener, ISignalChangeListener } from '../../../internal/register-signal/signal-get-called.private';
import { SIGNAL } from '../../../readonly-signal/traits/symbol/signal.symbol';
import { IPureSignal } from '../../signal.type';
import { ISignalMutateFunctionCallback } from '../../traits/mutate/signal.mutate.function-definition';
import { ISignalUpdateFunctionCallback } from '../../traits/update/signal.update.function-definition';
import { ISignalConstructor } from '../../types/signal-constructor.type';
import { ISignalOptions } from '../../types/signal-options.type';

/**
 * The Signal class.
 */
export class PureSignal<GValue> implements IPureSignal<GValue> {

  /**
   * Returns a thrown Signal.
   */
  static throw<GValue>(
    error: any,
  ): PureSignal<GValue> {
    return new PureSignal<GValue>(new SignalThrow(error));
  }

  readonly #equal: IEqualFunction<GValue>;

  #value: GValue | SignalThrow;
  #signalChangeListeners: ISignalChangeListener[];
  #dispatching: boolean;

  constructor(
    initialValue: GValue | SignalThrow,
    {
      equal = EQUAL_FUNCTION_STRICT_EQUAL,
    }: ISignalOptions<GValue> = {},
  ) {
    this.#equal = equal;

    this.#value = initialValue;
    this.#signalChangeListeners = [];
    this.#dispatching = false;
  }

  get [SIGNAL](): unknown {
    return true;
  }

  #addCurrentListener(): void {
    const currentSignalChangeListener: ISignalChangeListener | undefined = getCurrentSignalChangeListener();
    if (currentSignalChangeListener !== void 0) {
      this.#signalChangeListeners.push(currentSignalChangeListener);
    }
  }

  #notifiesListeners(): void {
    const signalChangeListeners: ISignalChangeListener[] = this.#signalChangeListeners;
    this.#signalChangeListeners = [];
    for (let i = 0, l = signalChangeListeners.length; i < l; i++) {
      signalChangeListeners[i]();
    }
  }

  // #observe(
  //   listener: ISignalChangeListener,
  // ): IUnsubscribe {
  //   const signalChangeListeners: ISignalChangeListener[] = this.#signalChangeListeners;
  //   const index: number = signalChangeListeners.push(listener) - 1;
  //
  //   return (): void => {
  //     if (this.#signalChangeListeners === signalChangeListeners) {
  //       signalChangeListeners[index] = noop;
  //     }
  //   };
  // }

  #getValue(): GValue {
    if (this.#value instanceof SignalThrow) {
      throw this.#value.error;
    } else {
      return this.#value;
    }
  }

  // get #value$(): IObservable<ISignalNotifications<GValue>> {
  //   return (
  //     emit: IObserver<ISignalNotifications<GValue>>
  //   ): IUnsubscribeOfObservable => {
  //     let running: boolean = true;
  //
  //     const loop = (): void => {
  //       this.#signalChangeListeners.push((): void => {
  //         if (running) {
  //           emit(this.#value);
  //         }
  //         if (running) {
  //           loop();
  //         }
  //       });
  //     };
  //
  //     return (): void => {
  //       running = false;
  //     };
  //   };
  // }

  // get #value$(): IObservable<ISignalNotifications<GValue>> {
  //   return (
  //     emit: IObserver<ISignalNotifications<GValue>>,
  //   ): IUnsubscribeOfObservable => {
  //     let running: boolean = true;
  //
  //     let signalChangeListeners: ISignalChangeListener[];
  //     let index: number;
  //
  //     const loop = (): void => {
  //       signalChangeListeners = this.#signalChangeListeners;
  //       index = signalChangeListeners.length;
  //       signalChangeListeners.push((): void => {
  //         emit(this.#value);
  //         if (running) {
  //           loop();
  //         }
  //       });
  //     };
  //
  //     return (): void => {
  //       if (running) {
  //         running = false;
  //         signalChangeListeners[index] = noop;
  //       }
  //     };
  //   };
  // }

  /**
   * Returns the signal's value, or throws if the signal is into an "error" state.
   *
   * - if run into a signal's context, it notifies this context that the signal has been used.
   */
  get(): GValue {
    this.#addCurrentListener();
    return this.#getValue();
  }

  /**
   * Sets a new value for this signal.
   *
   * - checks that the current signal's value and the new value differ, or `force` is `true`, before this value is actually set.
   * - if run into a signal's context, it ensures that writing is allowed.
   */
  set(
    value: GValue | SignalThrow,
  ): void {
    if (this.#dispatching) {
      throw new SignalContextError(`The signal is already dispatching a value.`);
    } else {
      if (
        (value instanceof SignalThrow)
        || (this.#value instanceof SignalThrow)
        || !this.#equal(value, this.#value)
      ) {
        this.#dispatching = true;
        this.#value = value;
        this.#notifiesListeners();
        this.#dispatching = false;
      }
    }
  }

  update(
    updateFunction: ISignalUpdateFunctionCallback<GValue>,
  ): void {
    this.set(updateFunction(this.get()));
  }

  /**
   * Sets the signal into an "error" state.
   *
   * - if run into a signal's context, it ensures that writing is allowed.
   */
  throw(
    error: any,
  ): void {
    this.#setValueAndNotifiesListeners(new SignalThrow(error));
  }

  // /**
  //  * Converts this signal into an Observable.
  //  *
  //  * Options:
  //  *  - `mode`: 2 modes are available
  //  *    - `value` (default): only the values are sent. if the signal enters into an "error" state, then `onError` is called (as default it simply logs the error).
  //  *    - `notification`: the signal state is sent as `next` or `error` notifications.
  //  *  - `emitCurrentValue` (default: `true`): if true, the observable will send the signal's current value.
  //  *  - `debounce` (default: `true`): if true, values will be debounced using `debounceMicrotaskObservable`. This improves performances when setting multiple times the signal's value during the same event loop.
  //  *  - `distinct` (default: `true`): if true, only distinct values are sent. This is only useful when `debounce` is `true`.
  //  */
  // toObservable(
  //   options?: ISignalToValueObservableOptions<GValue>,
  // ): IObservable<GValue>;
  // toObservable(
  //   options: ISignalToNotificationsObservableOptions,
  // ): IObservable<ISignalNotifications<GValue>>;
  // toObservable(
  //   {
  //     emitCurrentValue = true,
  //     debounce = true,
  //     distinct = true,
  //     mode = 'value',
  //     // @ts-ignore
  //     onError = DEFAULT_SIGNAL_TO_VALUE_OBSERVABLE_ON_ERROR_FUNCTION,
  //   }: ISignalToObservableOptions<GValue> = {},
  // ): IObservable<GValue> | IObservable<ISignalNotifications<GValue>> {
  //   if (mode === 'notification') {
  //     if (debounce) {
  //       const value$: IObservable<ISignalNotifications<GValue>> = emitCurrentValue
  //         ? merge([
  //           reference(() => this.#value),
  //           debounceMicrotaskObservable(this.#value$),
  //         ])
  //         : debounceMicrotaskObservable(this.#value$);
  //
  //       return distinct
  //         ? distinctObservable(
  //           value$,
  //           {
  //             equal: (a: ISignalNotifications<GValue>, b: ISignalNotifications<GValue>): boolean => {
  //               return (a.name === 'next')
  //                 && (b.name === 'next')
  //                 && this.#equal(a.value, b.value);
  //             },
  //           },
  //         )
  //         : value$;
  //     } else {
  //       return emitCurrentValue
  //         ? merge([
  //           reference(() => this.#value),
  //           this.#value$,
  //         ])
  //         : this.#value$;
  //     }
  //   } else {
  //     return mapFilterObservable(
  //       this.toObservable({
  //         emitCurrentValue,
  //         debounce,
  //         mode: 'notification',
  //       }),
  //       (notification: ISignalNotifications<GValue>): IMapFilterMapFunctionReturn<GValue> => {
  //         return (notification.name === 'next')
  //           ? notification.value
  //           : onError(notification.value);
  //       },
  //     );
  //   }
  // }
}

// export function signalToObservable<GValue>(
//   value$: IObservable<ISignalNotifications<GValue>>,
//   options?: ISignalToValueObservableOptions<GValue>,
// ): IObservable<GValue>;
// export function signalToObservable<GValue>(
//   value$: IObservable<ISignalNotifications<GValue>>,
//   options: ISignalToNotificationsObservableOptions,
// ): IObservable<ISignalNotifications<GValue>>;
// export function signalToObservable<GValue>(
//   value$: IObservable<ISignalNotifications<GValue>>,
//   {
//     emitCurrentValue = true,
//     debounce = true,
//     distinct = true,
//     mode = 'value',
//     // @ts-ignore
//     onError = DEFAULT_SIGNAL_TO_VALUE_OBSERVABLE_ON_ERROR_FUNCTION,
//   }: ISignalToObservableOptions<GValue> = {},
// ): IObservable<GValue> | IObservable<ISignalNotifications<GValue>> {
//   if (mode === 'notification') {
//     if (debounce) {
//       const value$: IObservable<ISignalNotifications<GValue>> = emitCurrentValue
//         ? merge([
//           reference(() => value),
//           debounceMicrotaskObservable(value$),
//         ])
//         : debounceMicrotaskObservable(value$);
//
//       return distinct
//         ? distinctObservable(
//           value$,
//           {
//             equal: (a: ISignalNotifications<GValue>, b: ISignalNotifications<GValue>): boolean => {
//               return (a.name === 'next')
//                 && (b.name === 'next')
//                 && equal(a.value, b.value);
//             },
//           },
//         )
//         : value$;
//     } else {
//       return emitCurrentValue
//         ? merge([
//           reference(() => value),
//           value$,
//         ])
//         : value$;
//     }
//   } else {
//     return mapFilterObservable(
//       this.toObservable({
//         emitCurrentValue,
//         debounce,
//         mode: 'notification',
//       }),
//       (notification: ISignalNotifications<GValue>): IMapFilterMapFunctionReturn<GValue> => {
//         return (notification.name === 'next')
//           ? notification.value
//           : onError(notification.value);
//       },
//     );
//   }
// }

export const Signal = Callable<typeof PureSignal, ISignalConstructor>(PureSignal, function(this: PureSignal<any>) {
  return this.get();
});



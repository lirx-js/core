import { Callable, EQUAL_FUNCTION_STRICT_EQUAL, IEqualFunction } from '@lirx/utils';
import { SignalContextError } from '../../../error/signal-context-error.class';
import { SignalThrow } from '../../../error/signal-throw.class';
import {
  getCurrentSignalChangeListener,
  ISignalChangeListener,
  runSignalChangeContextOnce,
} from '../../../internal/register-signal/signal-get-called.private';
import { SIGNAL } from '../../../readonly-signal/traits/symbol/signal.symbol';
import { IPureComputedSignal } from '../../computed-signal.type';
import { IComputedSignalConstructor } from '../../types/computed-signal-constructor.type';
import { IComputedSignalOptions } from '../../types/computed-signal-options.type';
import { IComputedSignalFunction } from '../../types/computed-singal-function.type';

/**
 * Represents a Computed Signal as a class.
 */
export class PureComputedSignal<GValue> implements IPureComputedSignal<GValue> {
  readonly #computedFunction: IComputedSignalFunction<GValue>;
  readonly #equal: IEqualFunction<GValue>;

  #value: GValue | SignalThrow;
  #signalChangeListeners: ISignalChangeListener[];
  #state: 'outdated' | 'updating' | 'up-to-date';

  constructor(
    computedFunction: IComputedSignalFunction<GValue>,
    {
      equal = EQUAL_FUNCTION_STRICT_EQUAL,
    }: IComputedSignalOptions<GValue> = {},
  ) {
    this.#computedFunction = computedFunction;
    this.#equal = equal;

    this.#value = new SignalThrow(void 0);
    this.#signalChangeListeners = [];
    this.#state = 'outdated';
  }

  get [SIGNAL](): unknown {
    return true;
  }

  #addCurrentListener(): void {
    const currentSignalChangeListener: ISignalChangeListener | undefined = getCurrentSignalChangeListener();
    if (currentSignalChangeListener !== void 0) {
      this.#signalChangeListeners.push(currentSignalChangeListener);
    }
  }

  #notifiesListeners(): void {
    const signalChangeListeners: ISignalChangeListener[] = this.#signalChangeListeners;
    this.#signalChangeListeners = [];
    for (let i = 0, l = signalChangeListeners.length; i < l; i++) {
      signalChangeListeners[i]();
    }
  }

  #getValue(): GValue {
    if (this.#value instanceof SignalThrow) {
      throw this.#value.error;
    } else {
      return this.#value;
    }
  }

  #computeValue(): GValue | SignalThrow {
    try {
      return this.#computedFunction();
    } catch (error: unknown) {
      if (error instanceof SignalContextError) {
        throw error;
      } else {
        return new SignalThrow(error);
      }
    }
  }

  #update(): void {
    if (this.#state === 'outdated') {
      runSignalChangeContextOnce(
        (): void => {
          this.#state = 'updating';
          this.#value = this.#computeValue();
          this.#state = 'up-to-date';
        },
        (): void => {
          // TODO recompute value and check is different => if yes, run again
          this.#state = 'outdated';

          runSignalChangeContextOnce(
            (): void => {
              this.#state = 'updating';
              const value: GValue | SignalThrow = this.#computeValue();
              this.#state = 'up-to-date';

              if (
                (value instanceof SignalThrow)
                || (this.#value instanceof SignalThrow)
                || !this.#equal(value, this.#value)
              ) {
                this.#value = value;
                this.#notifiesListeners();
              }
            },
            (): void => {
              this.#state = 'outdated';
            },
          );
        },
      );
    } else if (this.#state === 'updating') {
      throw new SignalContextError(`Circular Computed Signal.`);
    }
  }

  get(): GValue {
    this.#addCurrentListener();
    this.#update();
    return this.#getValue();
  }
}

export const ComputedSignal = Callable<typeof PureComputedSignal, IComputedSignalConstructor>(PureComputedSignal, function(this: PureComputedSignal<any>) {
  return this.get();
});

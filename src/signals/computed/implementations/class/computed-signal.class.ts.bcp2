import { Callable, EQUAL_FUNCTION_STRICT_EQUAL, IEqualFunction, noop } from '@lirx/utils';
import { createErrorNotification } from '../../../../misc/notifications/built-in/error/create-error-notification';
import { createNextNotification } from '../../../../misc/notifications/built-in/next/create-next-notification';
import { IObservable, IUnsubscribeOfObservable } from '../../../../observable/type/observable.type';
import { IObserver } from '../../../../observer/type/observer.type';
import { SignalContextError } from '../../../error/signal-context-error.class';
import { SignalThrow } from '../../../error/signal-throw.class';
import {
  getCurrentSignalChangeListener,
  ISignalChangeListener,
  runSignalChangeContext,
} from '../../../internal/register-signal/signal-get-called.private';
import { SIGNAL } from '../../../readonly-signal/traits/symbol/signal.symbol';
import {
  ISignalToNotificationsObservableOptions,
  ISignalToObservableOptions,
  ISignalToValueObservableOptions,
} from '../../../readonly-signal/traits/to-observable/signal-to-observable-options.type';
import { ISignalNotifications } from '../../../signal/types/signal-notifications.type';
import { IPureComputedSignal } from '../../computed-signal.type';
import { IComputedSignalConstructor } from '../../types/computed-signal-constructor.type';
import { IComputedSignalOptions } from '../../types/computed-signal-options.type';
import { IComputedSignalFunction } from '../../types/computed-singal-function.type';

/**
 * Represents a Computed Signal as a class.
 */
export class PureComputedSignal<GValue> implements IPureComputedSignal<GValue> {
  readonly #computedFunction: IComputedSignalFunction<GValue>;
  readonly #equal: IEqualFunction<GValue>;

  #value: GValue | SignalThrow;
  #signalChangeListeners: ISignalChangeListener[];
  #state: 'outdated' | 'updating' | 'up-to-date';

  constructor(
    computedFunction: IComputedSignalFunction<GValue>,
    {
      equal = EQUAL_FUNCTION_STRICT_EQUAL,
    }: IComputedSignalOptions<GValue> = {},
  ) {
    this.#computedFunction = computedFunction;
    this.#equal = equal;

    this.#value = new SignalThrow(void 0);
    this.#signalChangeListeners = [];
    this.#state = 'outdated';
  }

  get [SIGNAL](): unknown {
    return true;
  }

  #getValue(): GValue {
    if (this.#value instanceof SignalThrow) {
      throw this.#value.error;
    } else {
      return this.#value;
    }
  }

  #notifiesListeners( ): void {
    const signalChangeListeners: ISignalChangeListener[] = this.#signalChangeListeners;
    this.#signalChangeListeners = [];
    for (let i = 0, l = signalChangeListeners.length; i < l; i++) {
      signalChangeListeners[i]();
    }
  }

  #update(): void {
    if (this.#state === 'outdated') {
      this.#state = 'updating';
      runSignalChangeContext(
        (): void => {
          let value: GValue | SignalThrow;

          try {
            value = this.#computedFunction();
          } catch (error: unknown) {
            if (error instanceof SignalContextError) {
              throw error;
            } else {
              value = new SignalThrow(error);
            }
          }

          if (
            (value instanceof SignalThrow)
            || (this.#value instanceof SignalThrow)
            || !this.#equal(value, this.#value)
          ) {
            this.#value = value;
            this.#notifiesListeners(value);
          }
        },
        (): void => {
          this.#state = 'outdated';
        },
      );
      this.#state = 'up-to-date';
    } else if (this.#state === 'updating') {
      throw new SignalContextError(`Circular Computed Signal.`);
    }
  }

  // get #value$(): IObservable<ISignalNotifications<GValue>> {
  //   return (
  //     emit: IObserver<ISignalNotifications<GValue>>,
  //   ): IUnsubscribeOfObservable => {
  //     let running: boolean = true;
  //
  //     const loop = (): void => {
  //       if (running) {
  //         this.#update(loop);
  //       }
  //       if (running) {
  //         emit(this.#value);
  //       }
  //     };
  //
  //     return (): void => {
  //       running = false;
  //     };
  //   };
  // }

  get(): GValue {
    const currentSignalChangeListener: ISignalChangeListener | undefined = getCurrentSignalChangeListener();
    if (currentSignalChangeListener !== void 0) {
      this.#signalChangeListeners.push(currentSignalChangeListener);
    }
    this.#update();
    return this.#getValue();
  }

  // toObservable(
  //   options?: ISignalToValueObservableOptions<GValue>,
  // ): IObservable<GValue>;
  // toObservable(
  //   options: ISignalToNotificationsObservableOptions,
  // ): IObservable<ISignalNotifications<GValue>>;
  // toObservable(
  //   {
  //     emitCurrentValue = true,
  //     ...options
  //   }: ISignalToObservableOptions<GValue> = {},
  // ): IObservable<GValue | ISignalNotifications<GValue>> {
  //   return (emit: IObserver<GValue | ISignalNotifications<GValue>>): IUnsubscribeOfObservable => {
  //     if (emitCurrentValue && this.#pending) {
  //       this.#pending = false;
  //       this.#runLoop();
  //     }
  //
  //     const loop = (): void => {
  //       this.#update(loop);
  //       emit(this.#signal.get());
  //     };
  //
  //     return subscribe(emit);
  //   };
  // };
}

export const ComputedSignal = Callable<typeof PureComputedSignal, IComputedSignalConstructor>(PureComputedSignal, function(this: PureComputedSignal<any>) {
  return this.get();
});
